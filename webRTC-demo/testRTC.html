<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>客户端1</title>
    <style>
        .container{
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            height: 500px;
            background-color: cyan;
        }
        .msg-container {
            width: 300px;
            height: 200px;
            background-color: #FFF;
        }
    </style>
</head>
<body>
    <article class="container">
        <div>
            <input id="sendName" type="text">
            <button onclick="send('init')">请输入名称</button>
        </div>
        <div>
            <div id="msgHistory" class="msg-container"></div>
            <input id="receiveName" placeholder="接收者名称" type="text">
            <input id="instantMsg" placeholder="内容" type="text">
            <button onclick="send('instantMsg')">发送消息</button>
        </div>
        <div>
            <video width=400 height=300x style="background-color: green;" id="video-self" src="" autoplay>
                你的浏览器不支持video
            </video>
            <video width=400 height=300x style="background-color: orange;" id="video" src="" autoplay>
                你的浏览器不支持video
            </video>
            <button onclick="initRTC()">初始化webRTC</button>
            <button onclick="invite()">发送RTCoffer</button>
        </div>
    </article>

    <script>
        let WS = initWS();

        /**
         * @description initial websocket
         * @return {Object} websocket object
        */
        function initWS() {
            if(!Reflect.has(window, "WebSocket")) {
                console.log("浏览器不支持websocket!!");
                return;
            };

            let WS = new WebSocket("wss://www.fffuture.top");
            window.userws = WS;
            WS.onopen = function() {
                console.log("---成功连接websocket---");
            }

            WS.onmessage = function(evt) {
                console.log("---onmessage--:", evt);
                let data = JSON.parse(evt.data);
                if(data.type === "offer") {
                    answerOffer(data);
                }else if(data.type === "offer-answer") {
                    console.warn("offer-answer: ", data);
                    setRemoteSDP(data);
                }else if(data.type === "candidate") {
                    setRemoteICE(data);
                }
            }

            WS.onclose = function() {
                console.log("---已断开webSocket---");
            }

            WS.onerror = function(error) {
                console.error(error);
            }

            return WS;
        }


        /**
         * @descript send func
         * @param {String} type
        */
        function send(type) {
            let sendName = document.querySelector("#sendName").value,
                receiveName = document.querySelector("#receiveName").value,
                msgHistory = document.querySelector("#msgHistory"),
                instantMsg = document.querySelector("#instantMsg").value;
            
            let data = null;
            if(type === "init") {
                data = {type, id: sendName};
            }else if(type === "instantMsg") {
                try {
                    data = {type, send: sendName, receive: receiveName, content: instantMsg};
                    msgHistory.innerText += `${JSON.stringify(data)}\n `;
                } catch (error) {
                    console.error(error);
                }
            }
            WS.send(JSON.stringify(data));
        }


        var pc = null;

        function initRTC() {

            let sendName = document.querySelector("#sendName").value,
                receiveName = document.querySelector("#receiveName").value,
                msgHistory = document.querySelector("#msgHistory"),
                instantMsg = document.querySelector("#instantMsg").value;

            if(!sendName && !receiveName) return;

            const config = {
                iceServers: [
                    {
                        urls: "stun:139.224.75.6:3478",
                        username:"",
                        credential:""
                    },
                    {
                        urls: "turn:139.224.75.6:3478",
                        username: "wsj",
                        credential: "123456"
                    }
                ],
                iceTransportPolicy:"all",
                iceCandidatePoolSize:"0"
            };
            // console.log("--config:", config)；
            pc = new RTCPeerConnection(config);

            let mediaConstraints = {audio: true, video: true};

            navigator.mediaDevices.getUserMedia(mediaConstraints)
            .then(function(localStream) {
                // console.log("---获取本地媒体权限---");
                let videoSelf = document.querySelector("#video-self");
                videoSelf.srcObject = localStream;
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            })
            .catch(handleGetUserMediaError);

            function handleGetUserMediaError(e) {
                switch(e.name) {
                    case "NotFoundError":
                        alert("Unable to open your call because no camera and/or microphone were found.");
                        break;
                    case "SecurityError":
                        break;
                    case "PermissionDeniedError":
                        // Do nothing; this is the same as the user canceling the call.
                        break;
                    default:
                        alert("Error opening your camera and/or microphone: " + e.message);
                        break;
                }
                // closeVideoCall();
            }

            pc.ontrack = media => {
                console.log("----接收到远程的媒体流----", media);
                document.getElementById("video").srcObject = media.streams[0];
            }


            pc.onicecandidate = wapper => {
                if(!wapper.candidate) return;

                let msg = {
                    type: "candidate",
                    send: sendName,
                    receive: receiveName,
                    content: wapper.candidate
                }
                WS.send(JSON.stringify(msg));
            }

            pc.onnegotiationneeded = () => {
                console.log("---协商连接事件----")
                // console.warn("----WebRTC基础结构需要你重新启动会话协商过程onnegotiationneeded---");
            }

            pc.onicegatheringstatechange = () => {
                //非必要实现功能 除非你有特别的需求需要监视候选者的状态
                if (pc.iceGatheringState !== 'complete') return;
                console.log("----onicecandidate获取结束 gatheringStateChange: ");
            };

            pc.onicecandidateerror = error => {
                console.error("---获取候选者出错: ", error);
            };

        }

        /**
         * @description 将接收到的候选者icecandidate添加到pc(peerConnection)中
         * @param {Object} data icecandidate
        */
        function setRemoteICE(data) {
            // console.log("---接收到candidate: ", data);
            var candidate = new RTCIceCandidate(data.content);
            pc.addIceCandidate(candidate)
            .then(() => { console.log("---设置远程candidate成功--:") })
            .catch(err => { console.error("----设置candidate出错:　", error) })
        }

        /**
         * @description 将接收到的awseroffer的SDP设置到本地pc上
         * @param {Object} data
        */
        function setRemoteSDP(data) {
            const remoteDesc = new RTCSessionDescription(data.content);
            pc.setRemoteDescription(remoteDesc)
            .then(()=>{ console.log("---invite成功设置远程SDP"); });
        }

        /**
         * @description 回复offer
         * @param {Object} data
        */
        function answerOffer(data) {
            let send = document.querySelector("#sendName").value,
                receive = document.querySelector("#receiveName").value;
            if(!send && !receive) return;

            const remoteDesc = new RTCSessionDescription(data.content);
            console.log("-----remoteDesc: ----:", remoteDesc);
            pc.setRemoteDescription(remoteDesc)
            .then(function() { pc.createAnswer() })
            .then(function(answer) { return pc.setLocalDescription(answer) })
            .then(function() {
                // console.log("---成功设置invite的remoteSDP---");
                let data = {
                    type: "offer-answer",
                    send,
                    receive,
                    content: pc.localDescription
                };
                console.warn("---发送应答offer: ", JSON.stringify(data));
                WS.send(JSON.stringify(data));
            })
            .catch(err => { console.warn("--应答offer发生错误: ", err) })
        }

        /**
         * @description 发送offer
         * 
        */
        function invite() {
            let send = document.querySelector("#sendName").value,
                receive = document.querySelector("#receiveName").value;
            if(!send && !receive) return;

            let pc = window.pc;
            const offerOptions = { offerToReceiveVideo: 1, offerToReceiveAudio: 1};
            pc.createOffer(offerOptions)
            .then(gotDescription,noDescription );

            function gotDescription(desc) {
                console.log("---gotDescription: ", desc);
                pc.setLocalDescription(desc)
                .then(() => {
                    let data = {
                        type: "offer",
                        send,
                        receive,
                        content: pc.localDescription
                    };
                    console.warn("--设置本地offer成功，发送offer: ", JSON.stringify(data));
                    window.userws.send(JSON.stringify(data));
                });

            }

            function noDescription(error) {
                console.log('Error creating offer: ', error);
            }

        }

    </script>
</body>
</html>